---
layout: post
title: "ü¶Å Conquistando la Bestia de Big-O"
tags: [A&D, Algorithmics, Big-O]
---

Ahora que tenemos una comprensi√≥n b√°sica de la notaci√≥n `Big-O` gracias al `post` anterior (te invito a que lo revises),
podemos comenzar a buscar c√°lculos algo m√°s costosos para ir entendiendo como se evaluan los algoritmos a grandes rasgos.

¬°Imagina que est√°s organizando una gran fiesta y tienes una lista de invitados! Cada invitado tiene una edad determinada y quieres ordenar
la lista de invitados por *edad*, de *menor a mayor*. Podr√≠as optar por la estrategia de *fuerza bruta*, que consiste en comparar la edad
de cada invitado con la de todos los dem√°s, uno por uno.

Este m√©todo en programaci√≥n se conoce como "Bubble Sort" o "Ordenamiento de Burbuja" üìã, y es famoso por ser bastante lento...
bueno si espantosamente lento en rendimiento claro est√°. Veamos su implementaci√≥n:

```javascript
1. function bubbleSort(peopleInvited) {
2.  for (var i = 0; i < peopleInvited.length; i++) {
3.    // Notice that j < (length - i)
4.    for (var j = 0; j < peopleInvited.length - i - 1; j++) {
5.      // Compare the adjacent positions
6.      if (peopleInvited[j] > peopleInvited[j + 1]) {
7.        // Swap the numbers
8.        var tmp = peopleInvited[j];
9.        peopleInvited[j] = peopleInvited[j + 1];
10.       peopleInvited[j + 1] = tmp;
11.     }
12.    }
13.  }
14.
15.  return peopleInvited;
16. }
```

En el ejemplo de c√≥digo del post anterior vimos la implementaci√≥n del m√©todo `find(array, value)` donde ten√≠amos un bucle `for`,
por lo que nuestra notaci√≥n `Big-O` era bastante sencilla, pero en este ejemplo tenemos dos bucles `for`
y est√°n *anidados* uno dentro del otro.

‚ùì *¬øQu√© significa esto para nuestro rendimiento?*

üé• Vamos a desglosarlo un poco:

- L√≠nea 2: Esto es como contar a todos los invitados de la fiesta, que llamaremos `n` (cantidad de invitados). Esto ser√≠a `O(n)`.
- L√≠nea 4: Aqu√≠ estamos contando de nuevo, pero esta vez nos saltamos al √∫ltimo invitado que ya hemos comparado anteriormente. Esto ser√≠a `O(n-1)`.
- L√≠neas 6, 8, 9, 10 y 15: Podr√≠amos pensar que esto se ejecuta para cada elemento de la lista de invitados (que en el peor de los casos es as√≠),
pero en realidad evaluamos el tiempo de ejecuci√≥n de *forma aislada*, es decir, de forma aislada esta sentencia `if` se ejecuta una vez.
Esto se llama como hemos visto `tiempo constante` y lo escribimos como **O(1)**. A medida que aumenta el tama√±o de los datos **(n)**,
no cambia la cantidad de veces que se ejecuta este fragmento de c√≥digo.

üòï Se que esta √∫ltima parte pueda causar alg√∫n tipo de confusi√≥n al decir ejecutarse de forma a√≠slada, hacemos una breve explicaci√≥n previo a continuar
para ir entendiendo como funciona todas estas conclusiones que vamos descubriendo:

> Lo que el texto intenta decir es que en un an√°lisis aislado, la sentencia `if` y las l√≠neas de c√≥digo dentro del bloque `if` (l√≠neas 8, 9 y 10) tienen un tiempo de ejecuci√≥n constante, es decir, `O(1)`.
> Esto significa que el n√∫mero de operaciones que estas l√≠neas de c√≥digo realizan no depende del tama√±o de la entrada (en este caso, la longitud de peopleInvited).

> Sin embargo, es importante destacar que esto no significa que la sentencia `if` y el bloque de c√≥digo dentro de ella se ejecuten solo
> una vez durante todo el algoritmo. De hecho, se ejecutan muchas veces, dependiendo de c√≥mo est√©n organizados los elementos en el array
> peopleInvited.

> ‚úçÔ∏è Para ser m√°s espec√≠fico:

> - El bucle interno en la l√≠nea 4 se ejecuta `n-1` veces en la primera iteraci√≥n, luego `n-2` veces, luego `n-3` veces, y as√≠ sucesivamente.
> - La sentencia `if` en la l√≠nea 6 se eval√∫a en cada iteraci√≥n del bucle interno. Es decir, se eval√∫a `(n-1) + (n-2) + (n-3) + ... + 1` veces en total, que es igual a `n(n-1)/2` veces.
> - Las l√≠neas 8, 9, y 10 (que realizan el intercambio de elementos) solo se ejecutan cuando la condici√≥n en la l√≠nea 6 es verdadera, lo cual puede variar.

üéØ Cuando se habla de la notaci√≥n Big-O, estamos interesados en c√≥mo crece el tiempo de ejecuci√≥n a medida que el tama√±o de la entrada aumenta.

Ahora, la parte divertida es juntarlo todo. Pero antes de hacerlo, necesitamos recordar una regla crucial de la notaci√≥n **Big-O**:

- üí° Simplificar, simplificar y simplificar. Nos importa la tendencia general a largo plazo, no los detalles minuciosos del algoritmo.

ü§ù As√≠ que, a la hora de simplificar, seguimos estas reglas :

1. **O(5)** sigue siendo un **tiempo constante** y se escribir√° como **O(1)**.
2. **O(2n)** sigue siendo un **tiempo lineal** y se escribir√° como **O(n)**. 
3. **O(n - 3)** => O(n)
4. **O(n^3 + n^2)** => O(n^3)
5. **O(150x + 650y)** => O(x + y) "x" e "y" son valores diferentes, por lo que no puedo tirarlos, ni combinarlos.

Entonces, de vuelta a nuestra fiesta. La l√≠nea 4 de **O(n-1)** se simplifica a **O(n)** porque estamos desechando el t√©rmino menos significativo.
Las l√≠neas 6, 8, 9, 10 y 15 son t√©rminos de tiempo constante **O(1)**, y todos son menos significativos, por lo que tambi√©n podemos descartarlos.
Nos quedamos con la **O(n)** del bucle exterior y la **O(n)** del bucle interior.

Ahora bien, ¬øqu√© hacemos con estos dos valores de `n`? ¬øLos sumamos o los multiplicamos?
Bueno, eso depende de si los bucles est√°n "anidados" o son "adyacentes".

- Si est√°n anidados, como en nuestro algoritmo de ordenamiento, los multiplicamos.
- Si son adyacentes, los sumar√≠amos.

Por lo tanto, siguiendo todas estas reglas, la complejidad del algoritmo para acomodar los invitados por edad, es decir,
nuestro algoritmo de Bubble Sort o fuerza bruta, es **O(n*n)**, que tambi√©n podemos escribirlo como **O(n^2)**.

üß† Esto significa que si tuvieras 100 invitados en tu fiesta, terminar√≠as haciendo alrededor de 10,000 comparaciones en el peor de los casos (100 invitados * 100 comparaciones por invitado = 10,000 comparaciones).
Y si tuvieras 1,000 invitados, ¬°terminar√≠as haciendo alrededor de 1,000,000 de comparaciones! Como puedes ver,
el rendimiento de Bubble Sort se deteriora muy r√°pidamente a medida que el n√∫mero de invitados aumenta.

üóûÔ∏è Adem√°s te dejo un ejemplo del algoritmo para que puedas visualizarlo mejor a su funcionamiento:

- En cada "paso" del algoritmo, se comparan los a√±os de dos invitados consecutivos.
Si el primer invitado es mayor que el segundo, intercambias sus posiciones en la lista.
De esta manera, el invitado de mayor edad "burbujea" hacia el final de la lista a medida que se ejecuta cada paso.
Este proceso se repite desde el inicio de la lista hasta que no se necesiten m√°s intercambios,
lo que indica que la lista est√° completamente ordenada‚Äã.

Aqu√≠ est√° el proceso paso a paso con la lista de edades de los 5 invitados que usaremos de ejemplos con sus edades [(35, 22, 45, 30, 26)]:

1Ô∏è‚É£ Primer Paso
```bash
(35, 22, 45, 30, 26) ‚Üí (22, 35, 45, 30, 26) // Se intercambian 35 y 22 porque 35 > 22

(22, 35, 45, 30, 26) ‚Üí (22, 35, 45, 30, 26) // No se intercambian 35 y 45 porque 35 < 45

(22, 35, 45, 30, 26) ‚Üí (22, 35, 30, 45, 26) // Se intercambian 45 y 30 porque 45 > 30

(22, 35, 30, 45, 26) ‚Üí (22, 35, 30, 26, 45) // Se intercambian 45 y 26 porque 45 > 26
```
2Ô∏è‚É£ Segundo Paso
```bash
(22, 35, 30, 26, 45) ‚Üí (22, 35, 30, 26, 45) // No se intercambian 22 y 35 porque 22 < 35

(22, 35, 30, 26, 45) ‚Üí (22, 30, 35, 26, 45) // Se intercambian 35 y 30 porque 35 > 30

(22, 30, 35, 26, 45) ‚Üí (22, 30, 26, 35, 45) // Se intercambian 35 y 26 porque 35 > 26

(22, 30, 26, 35, 45) ‚Üí (22, 30, 26, 35, 45) // No se intercambian 35 y 45 porque 35 < 45
```
3Ô∏è‚É£ Tercer Paso
```bash
(22, 30, 26, 35, 45) ‚Üí (22, 30, 26, 35, 45) // No se intercambian 22 y 30 porque 22 < 30

(22, 30, 26, 35, 45) ‚Üí (22, 26, 30, 35, 45) // Se intercambian 30 y 26 porque 30 > 26

(22, 26, 30, 35, 45)
```

Es por esto que, aunque **Bubble Sort** es un algoritmo f√°cil de entender e implementar, rara vez se usa en la pr√°ctica para listas grandes.
Existen otros algoritmos de ordenamiento m√°s eficientes, como Quicksort, Mergesort y Heapsort,
que tienen una mejor complejidad de tiempo en el peor de los casos.

¬°Y ah√≠ lo tienes! Ahora puedes lucirte en la pr√≥xima fiesta de programadores hablando de la notaci√≥n Big-O y su aplicaci√≥n en el Bubble Sort.
Y si alguien te pregunta c√≥mo lo aprendiste, puedes decirles que fue en una Fiesta con invitados ü•≥.

Tambi√©n podes encontrar la versi√≥n en ingl√©s dentro del [Blog Rooftop](https://tinyurl.com/big-o-part-2) 

Espero verte pronto en la pr√≥xima edici√≥n donde veremos los diferentes tipos de complejidades de tiempo m√°s a detalle. üëã
