---
layout: post
title: "ü§Ø Desentra√±ando Big O: Un viaje desde O(1) hasta O(n!)"
tags: [A&D, Algorithmics, Big-O]
---

¬°Bienvenidos nuevamente a la continuaci√≥n de nuestra serie sobre Big O! Si esta es tu primera entrada al blog y est√°s interesado en este tema (muchas veces por necesidad debido a las entrevistas, pero interesado de alguna forma para mejorar...) es probable que te hayas hecho algunas de estas preguntas:

‚ùì ¬øC√≥mo los ingenieros de software o los programadores, como prefieras llamarlos, eval√∫an la eficiencia de los algoritmos? ¬øC√≥mo deciden cu√°l es el mejor m√©todo para resolver un problema espec√≠fico? La respuesta a menudo se encuentra en un tipo de an√°lisis matem√°tico conocido como Notaci√≥n Big O.

Big O es un componente esencial en inform√°tica que permite a los profesionales comparar la eficiencia de diferentes algoritmos en t√©rminos de tiempo de ejecuci√≥n y recursos consumidos. Gracias a Big O, podemos prever c√≥mo se comportar√° un algoritmo a medida que aumenta el volumen de datos. Esto es crucial para tomar decisiones informadas y objetivas sobre qu√© algoritmo utilizar en una situaci√≥n dada.

En esta publicaci√≥n, nos embarcaremos en un viaje a trav√©s de los diferentes tipos de Notaci√≥n Big O, desde el tiempo constante `(O(1))` hasta el tiempo factorial `(O(n!))`, explorando c√≥mo cada uno impacta en el rendimiento de nuestros algoritmos. Adem√°s, proporcionaremos ejemplos de c√≥digo, ventajas y desventajas, as√≠ como algunas aplicaciones pr√°cticas de cada uno. Y para ayudarte a visualizar c√≥mo var√≠a el tiempo de ejecuci√≥n en funci√≥n de los datos ingresados, tambi√©n incluiremos gr√°ficos descriptivos de cada tipo. As√≠ que si est√°s listo para desentra√±ar los misterios de la Notaci√≥n Big O, ¬°comencemos üèÅ!

## Constant Time - O(1)

El tiempo constante, denotado como `O(1)`, describe un algoritmo cuyo tiempo de ejecuci√≥n es independiente de la cantidad de datos. Imagina que tienes un libro y quieres ver la primera p√°gina. No importa si el libro tiene 100 o 1.000 p√°ginas, siempre te llevar√° la misma cantidad de tiempo abrirlo y ver la primera p√°gina. Este es un buen ejemplo del tiempo constante en la vida real: el n√∫mero de p√°ginas (datos) en el libro no afecta el tiempo que se necesita para realizar la operaci√≥n (abrir la primera p√°gina).

Aqu√≠ te dejo un ejemplo a nivel de c√≥digo de una funci√≥n que no toma argumentos y siempre devuelve el mismo resultado. No depende de ninguna entrada y, por lo tanto, es un algoritmo de tiempo constante `O(1)`.

```javascript
const sayHello = () => 'Hello world';
```

**Ejemplos de Uso Com√∫n**
Un buen ejemplo de tiempo constante es acceder a un elemento espec√≠fico en un array por su √≠ndice. Independientemente del tama√±o del array, el tiempo de ejecuci√≥n para acceder a un elemento por su √≠ndice ser√° siempre el mismo.

1) Si tienes un array de millones de elementos y quieres acceder al elemento en el √≠ndice `500.000`, puedes hacerlo directamente y el tiempo que tomar√° no ser√° afectado por la longitud del array.

```javascript
const array = [1, 2, 3, 4, 5, ..., 1,000,000];

console.log(array[500000]);
```

2) Determinar si un n√∫mero es par o impar. Sin importar lo grande que sea el n√∫mero, el tiempo de ejecuci√≥n ser√° el mismo.

```javascript
const isEven = (n) => n % 2 === 0;
```

3) Acceder a un valor en un objeto por su clave. Independientemente de cu√°ntas propiedades tenga el objeto, siempre toma la misma cantidad de tiempo recuperar un valor si conoces la clave.

```javascript
const user = {
  name: 'Mat√≠as',
  age: 28,
  city: 'C√≥rdoba',
  // M√°s propiedades...
};

console.log(user.name);
```

Espero que estos ejemplos te ayuden a ilustrar mejor el concepto de tiempo constante `O(1)`. Recuerda, la clave aqu√≠ es que el tiempo de ejecuci√≥n no cambia, sin importar cu√°ntos datos est√© manejando el algoritmo.

**Ventajas y Desventajas**
Los algoritmos de tiempo constante son los m√°s eficientes en t√©rminos de tiempo de ejecuci√≥n. Esto es ideal para operaciones que se deben realizar r√°pidamente y que no dependen del n√∫mero de elementos a procesar.

La desventaja, sin embargo, es que este tipo de algoritmos no son √∫tiles para tareas que requieran procesar o manipular m√∫ltiples elementos de datos, como ordenar un array o buscar un elemento espec√≠fico en una lista no ordenada.

**Diagramas**
En este caso, el tiempo de ejecuci√≥n no cambia con el tama√±o de la entrada. As√≠ que si trazas esta funci√≥n, simplemente obtienes una l√≠nea horizontal. En un plano `x-y`, puedes graficar la funci√≥n `f(x) = 1`.

<p align="center"><img width="50%" src="../images/bigonotation/big-o-3-1.png"/></p>

## **Logarithmic Time - O(log n)**

Un algoritmo de tiempo logar√≠tmico, o `O(log n)`, es aquel cuyo tiempo de ejecuci√≥n se reduce a la mitad con cada iteraci√≥n del algoritmo. Imagina que est√°s buscando un n√∫mero en una gu√≠a telef√≥nica. En lugar de comenzar en la primera p√°gina y revisar cada n√∫mero uno por uno, abres la gu√≠a por la mitad y decides si el n√∫mero que buscas est√° antes o despu√©s de la p√°gina a la que abriste. Este proceso se repite hasta que encuentres el n√∫mero. Eso es b√°sicamente lo que hace un algoritmo de tiempo logar√≠tmico.

Un ejemplo de un algoritmo de este tipo es la b√∫squeda binaria, que es usada para encontrar un elemento en una lista ordenada.

```javascript
const binarySearch = (list, item) => {
  let low = 0;
  let high = list.length - 1;

  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    let guess = list[mid];

    if (guess === item) {
      return mid;
    }

    if (guess < item) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  
  return null;
}
```

**Ejemplos de Uso Com√∫n**

- La b√∫squeda binaria se utiliza a menudo en aplicaciones de bases de datos. Cuando se busca un registro espec√≠fico en una base de datos grande y ordenada, la b√∫squeda binaria puede encontrar r√°pidamente el registro. De igual manera, los √°rboles binarios de b√∫squeda, que son estructuras de datos basadas en la idea de la b√∫squeda binaria, son utilizados en muchas aplicaciones, incluyendo compiladores y sistemas de gesti√≥n de bases de datos.

- B√∫squeda en un diccionario: Si est√°s buscando una palabra en un diccionario f√≠sico, no empezar√≠as por la primera p√°gina y avanzar√≠as una por una. En cambio, abrir√≠as el diccionario aproximadamente a la mitad y determinar√≠as si la palabra que buscas estar√≠a antes o despu√©s en el diccionario, y luego repetir√≠as el proceso en la mitad correspondiente.

- Adivinanzas num√©ricas: Si est√°s jugando un juego en el que tienes que adivinar un n√∫mero entre 1 y 100, y en cada intento se te dice si tu suposici√≥n es demasiado alta o demasiado baja, una estrategia eficiente ser√≠a comenzar en el medio (50) y ajustar tus conjeturas hacia arriba o hacia abajo seg√∫n las pistas. De esta manera, con cada conjetura, reduces a la mitad el rango de n√∫meros posibles.

**Ventajas y Desventajas**

La mayor ventaja de los algoritmos de tiempo logar√≠tmico es su eficiencia en conjuntos de datos grandes. A medida que el tama√±o del conjunto de datos crece, el tiempo de ejecuci√≥n de estos algoritmos crece de manera muy lenta en comparaci√≥n con algoritmos de tiempo lineal o cuadr√°tico.

No obstante, una desventaja de los algoritmos de tiempo logar√≠tmico es que requieren datos ordenados, lo cual puede a√±adir tiempo adicional o resultar inviable en ciertas situaciones.

**Consejos para entender mejor O(log n)**

- Siempre recuerda que el logaritmo es el inverso de la exponenciaci√≥n. Por lo tanto, si `2^3` = 8, entonces log<sub>2</sub>(8) = 3. Esto significa que necesitamos hacer 3 pasos en el peor de los casos para buscar un elemento en 8 elementos. Esta es la base de la b√∫squeda binaria.
- Es crucial entender que los algoritmos O(log n) requieren datos ordenados para funcionar correctamente. Esta es una consideraci√≥n importante en su aplicaci√≥n pr√°ctica.
- No confundas O(log n) con O(n log n). Este √∫ltimo es t√≠pico de algoritmos como el ordenamiento por mezcla o el ordenamiento r√°pido, que son m√°s costosos en t√©rminos de tiempo de ejecuci√≥n que los algoritmos O(log n).

**Diagramas**

En este caso, el tiempo de ejecuci√≥n aumenta logar√≠tmicamente con el tama√±o de la entrada. Es decir, a medida que n se hace muy grande, el tiempo de ejecuci√≥n aumenta, pero muy lentamente. En un plano x-y, puedes graficar la funci√≥n f(x) = log(x).

<p align="center"><img width="50%" src="../images/bigonotation/big-o-3-2.png"/></p>

## **Linear Time - O(n)**

El tiempo lineal, o `O(n)`, describe un algoritmo cuyo tiempo de ejecuci√≥n aumenta de manera directamente proporcional a la cantidad de datos de entrada. Imagina que est√°s en una fila de personas y quieres darle la mano a cada una. La cantidad de tiempo que te tomar√° realizar esta tarea ser√° proporcional al n√∫mero de personas en la fila. Si hay 5 personas, te llevar√° 5 veces el tiempo que te llevar√≠a si solo hubiera una persona. Este es el comportamiento t√≠pico de los algoritmos de tiempo lineal.

Un ejemplo de un algoritmo de tiempo lineal es recorrer una lista o un array de elementos, como en el siguiente c√≥digo en JavaScript:

```javascript
const printColors = (colors) => {
  for (let i = 0; i < colors.length; i++) {
    console.log(colors[i]);
  }
}
```

**Ejemplos de Uso Com√∫n**

El tiempo lineal es com√∫n en muchos algoritmos de programaci√≥n cotidiana.

- Cada vez que recorres una lista de elementos, como en una lista de tareas pendientes.
- Cuando filtras una lista de datos, est√°s utilizando algoritmos de tiempo lineal.
- Cambiar el color del texto de todos los elementos de una lista en una p√°gina web.
- Buscar un elemento espec√≠fico en un array no ordenado.
- Tambi√©n son comunes en operaciones como el mapeo de una lista a otra y la clonaci√≥n de arrays.

Todos estos ejemplos implican operaciones que se realizar√°n una vez por cada elemento del conjunto de datos.


**Ventajas y Desventajas**

El tiempo lineal es directo y f√°cil de entender. Su principal ventaja es que no tiene requerimientos espec√≠ficos acerca de los datos, a diferencia del tiempo logar√≠tmico que requiere que los datos est√©n ordenados.

Sin embargo, los algoritmos de tiempo lineal pueden ser ineficientes para conjuntos de datos muy grandes. Por ejemplo, si tienes que recorrer una lista de un mill√≥n de elementos, el tiempo de ejecuci√≥n ser√° proporcionalmente alto. Si un algoritmo de tiempo lineal toma 1 segundo para procesar 1000 elementos, este tardar√° aproximadamente 1000 segundos (o alrededor de 16 minutos y 40 segundos) para procesar 1 mill√≥n de elementos.

**Diagramas**

Aqu√≠, el tiempo de ejecuci√≥n aumenta linealmente con el tama√±o de la entrada. Si la entrada se duplica, el tiempo de ejecuci√≥n tambi√©n se duplica. En un plano x-y, puedes graficar la funci√≥n `f(x) = x`.

<p align="center"><img width="50%" src="../images/bigonotation/big-o-3-3.png"/></p>

Al dominar el concepto del tiempo lineal, tendr√°s una mejor comprensi√≥n de c√≥mo optimizar tus algoritmos para manejar conjuntos de datos grandes. Recuerda siempre considerar el tama√±o de tus datos al elegir el algoritmo m√°s eficiente para tu tarea.

## Super-Linear Time - O(n log n)

El tiempo super-lineal, o `O(n log n)`, describe un algoritmo cuyo tiempo de ejecuci√≥n es superior al lineal pero inferior al cuadr√°tico. Este tipo de complejidad temporal se encuentra a menudo en algoritmos que dividen el problema en subproblemas m√°s peque√±os, los resuelven de manera independiente y luego combinan las soluciones. Para entenderlo, imagina que est√°s ordenando una biblioteca de libros. Si tuvieras que comparar cada libro con cada otro libro (lo que ser√≠a tiempo cuadr√°tico), te llevar√≠a mucho tiempo. Pero si en cambio, pudieras dividir los libros en grupos m√°s peque√±os, ordenar esos grupos y luego combinar esos grupos ordenados, te tomar√≠a menos tiempo. Este proceso de dividir y conquistar es m√°s eficiente que los enfoques de tiempo cuadr√°tico y es la esencia de algoritmos `O(n log n)` como el Merge Sort.

Un ejemplo de un algoritmo de tiempo superlineal es el algoritmo de ordenamiento Merge Sort:

```javascript
const mergeSort = (arr) => {
  // Si la longitud del array es menos que 2, se retorna el array tal como est√°.
  if (arr.length < 2) {
    return arr;
  }

  // Encuentra el √≠ndice medio del array.
  const middle = Math.floor(arr.length / 2);

  // Divide el array en dos mitades alrededor del √≠ndice medio.
  const left = arr.slice(0, middle);
  const right = arr.slice(middle);

  // Ordena recursivamente ambas mitades y luego las combina.
  return merge(mergeSort(left), mergeSort(right));
}

const merge = (left, right) => {
  const sorted = [];

  // Compara los elementos de las mitades izquierda y derecha,
  // y los coloca en el array 'sorted' en el orden correcto.
  while (left.length && right.length) {
    if (left[0] <= right[0]) {
      sorted.push(left.shift());
    } else {
      sorted.push(right.shift());
    }
  }

  // Combina el array 'sorted' con los restantes elementos de las mitades.
  return [...sorted, ...left, ...right];
}
```

**Ejemplos de Uso Com√∫n**

Los algoritmos de tiempo superlineal como `Merge Sort, Heap Sort y Quick Sort` son ampliamente utilizados en la vida real para ordenar grandes conjuntos de datos. Esto se debe a que son m√°s eficientes que los algoritmos de ordenamiento cuadr√°tico como `Bubble Sort o Insertion Sort`, especialmente para grandes vol√∫menes de datos.

**Ventajas y Desventajas**

La principal ventaja de los algoritmos de tiempo superlineal es su eficiencia en conjuntos de datos de gran tama√±o. Esto se debe a que el n√∫mero de comparaciones requeridas crece m√°s lentamente que el tama√±o de la entrada. Sin embargo, estos algoritmos suelen ser m√°s complejos de implementar y entender que los algoritmos de tiempo lineal. Adem√°s, algunos de ellos, como Merge Sort, necesitan espacio adicional en memoria para almacenar una copia temporal de los datos, lo que puede ser costoso para conjuntos de datos muy grandes.

**Diagramas**

En este caso, el tiempo de ejecuci√≥n es mayor que lineal pero menos que polinomial. T√≠picamente, algoritmos como el de ordenaci√≥n r√°pida caen en esta categor√≠a. Puedes graficar la funci√≥n `f(x) = x * log(x)`.

<p align="center"><img width="50%" src="../images/bigonotation/big-o-3-4.png"/></p>

Comparaciones con los mencionados `O(n)` y `O(n^2)`

<p align="center"><img width="50%" src="../images/bigonotation/big-o-3-5.png"/></p>

üí° **Consejo**

Al enfrentarte a problemas de codificaci√≥n que implican ordenar o buscar en grandes conjuntos de datos, recuerda que los algoritmos `O(n log n)` son una opci√≥n muy eficiente. No obstante, tambi√©n es importante tener en cuenta los recursos de memoria disponibles, ya que algunos de estos algoritmos pueden requerir espacio adicional. Recuerda siempre sopesar los pros y los contras en funci√≥n de las especificaciones de tu problema en particular. Al final del d√≠a, la correcta elecci√≥n y implementaci√≥n de los algoritmos puede hacer una gran diferencia en el rendimiento de tu aplicaci√≥n.

**Conclusi√≥n**

El tiempo super-lineal o `O(n log n)` es una complejidad algor√≠tmica que encuentra un equilibrio efectivo entre simplicidad y eficiencia. Los algoritmos que tienen esta complejidad, como Merge Sort o Quick Sort, suelen ser una excelente opci√≥n para manipular grandes conjuntos de datos, ya que aumentan su tiempo de ejecuci√≥n de forma m√°s lenta en comparaci√≥n con algoritmos de tiempo cuadr√°tico. Sin embargo, el costo de esta eficiencia puede ser un mayor uso de memoria y una implementaci√≥n m√°s compleja.

## Polynomial Time - O(n^2)

El tiempo polinomial, denotado como `O(n^k)`, describe un algoritmo cuyo tiempo de ejecuci√≥n es proporcional a una potencia `k` del tama√±o de la entrada. Un caso com√∫n es `O(n^2)`, que ocurre cuando necesitas recorrer una lista de elementos dos veces - una vez para cada elemento de la lista. Imagina que est√°s en una fiesta y debes dar la mano a cada persona. Para cada individuo `(n)`, debes saludar a todos los dem√°s `(n-1)`. Este caso, que es cuadr√°tico, es solo un ejemplo de tiempo polinomial, ya que el tiempo polinomial tambi√©n puede referirse a complejidades como `O(n^3)`, `O(n^4)`, y as√≠ sucesivamente.

Un ejemplo cl√°sico de un algoritmo de tiempo polinomial es el Bubble Sort. Este algoritmo de ordenamiento funciona recorriendo la lista varias veces y, en cada pasada, compara cada elemento con el siguiente y los intercambia si est√°n en el orden incorrecto. Este proceso se repite hasta que la lista est√° ordenada.

```javascript
const bubbleSort = (arr) => {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        const temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}
```

Un buen ejemplo de un algoritmo de tiempo c√∫bico `O(n^3)` en el contexto de una plataforma de comercio electr√≥nico podr√≠a ser una funci√≥n que compara cada combinaci√≥n posible de tres productos diferentes para determinar si cumplen ciertos criterios.

Por ejemplo, supongamos que estamos buscando una combinaci√≥n de tres productos cuya suma total de precios sea igual a un valor determinado (como en el problema del `subset-sum`). El c√≥digo ser√≠a algo como lo siguiente:

```javascript
function findProductCombination(products, targetPrice) {
  for (let i = 0; i < products.length; i++) {
    for (let j = i + 1; j < products.length; j++) {
      for (let k = j + 1; k < products.length; k++) {
        if (products[i].price + products[j].price + products[k].price === targetPrice) {
          return [products[i], products[j], products[k]];
        }
      }
    }
  }
  return null;
}
```

La funci√≥n `findProductCombination` tiene una complejidad de tiempo de `O(n^3)`, ya que hay tres bucles anidados, cada uno de los cuales puede recorrer potencialmente la totalidad de la lista de productos. Esto ser√≠a necesario si estuvi√©semos buscando una combinaci√≥n espec√≠fica de tres productos que sumen un precio objetivo, y la √∫nica forma de encontrarla ser√≠a revisar todas las posibles combinaciones de tres productos.

Sin embargo, es importante se√±alar que este tipo de algoritmo puede ser muy ineficiente para grandes conjuntos de datos, ya que el tiempo de ejecuci√≥n aumenta al cubo del tama√±o de la lista de productos. En la mayor√≠a de los casos, ser√≠a preferible encontrar una soluci√≥n m√°s eficiente, especialmente si est√°s trabajando con un gran cat√°logo de productos.

**Ejemplos de Uso Com√∫n**

Los algoritmos de tiempo polinomial, como Bubble Sort, Insertion Sort y Selection Sort, tienen su lugar cuando los conjuntos de datos son peque√±os, o la simplicidad del c√≥digo es una ventaja, a pesar de que su tiempo de ejecuci√≥n puede crecer r√°pidamente a medida que aumenta el tama√±o del conjunto de datos.

**Ventajas y Desventajas**

La ventaja de los algoritmos de tiempo polinomial radica en su simplicidad para entender e implementar. Adem√°s, pueden ser efectivos para conjuntos de datos peque√±os. Sin embargo, su principal desventaja es su escalabilidad. A medida que el tama√±o del conjunto de datos aumenta, el tiempo de ejecuci√≥n de estos algoritmos puede volverse prohibitivamente grande.

**Diagramas**

El tiempo de ejecuci√≥n es proporcional al cuadrado (o cubo, etc.) del tama√±o de la entrada. Puedes graficar la funci√≥n `f(x) = x^2` para `O(n^2)` y `f(x) = x^3` para `O(n^3)`.

<p align="center"><img width="50%" src="../images/bigonotation/big-o-3-6.png"/></p>

**Conclusiones**
En tu an√°lisis de los algoritmos y su complejidad, es importante recordar que el hecho de que un algoritmo tenga una complejidad de tiempo polin√≥mica (como `O(n^2)` o `O(n^3)`) no lo hace necesariamente "malo". Depende del contexto y del tama√±o de los datos con los que est√°s trabajando como muchas cosas en programaci√≥n siempre hay que tener en cuenta el contexto adicional que tenemos en el momento.

Para conjuntos de datos peque√±os, un algoritmo polinomial puede ser adecuado e incluso preferible por su simplicidad. Sin embargo, a medida que el tama√±o del conjunto de datos aumenta, estos algoritmos pueden volverse muy ineficientes.

Adem√°s, ten en cuenta que, aunque un algoritmo puede tener una peor complejidad de tiempo en la teor√≠a, puede tener mejoras significativas en la pr√°ctica debido a las optimizaciones del compilador o de la m√°quina subyacente que utilizamos como servidor.

Un buen desarrollador siempre busca el equilibrio entre la eficiencia, la legibilidad y la mantenibilidad del c√≥digo, donde actualmente por las maquinas que tenemos acceso la legibilidad y la mantenibilidad de c√≥digo suelen ser las mayores prioridades que tenemos. Si bien es importante ser consciente de la eficiencia del algoritmo, la claridad y la simplicidad del c√≥digo tambi√©n son cruciales en la mayor√≠a de los entornos que se programan hoy en d√≠a en la web.

Por √∫ltimo, en casos donde la eficiencia es crucial y est√°s tratando con grandes conjuntos de datos, puedes considerar otras t√©cnicas como algoritmos de ordenamiento m√°s eficientes (como merge sort o quicksort), algoritmos de b√∫squeda eficientes (como la b√∫squeda binaria), o estructuras de datos eficientes (como los √°rboles de b√∫squeda binaria).

## Exponential Time - O(2^n)

Los algoritmos con tiempo de ejecuci√≥n exponencial, o `O(2^n)`, tienen un tiempo de ejecuci√≥n que crece exponencialmente con cada nuevo elemento en la entrada. Esto significa que cada elemento adicional puede duplicar (o m√°s) el tiempo de ejecuci√≥n.

Un ejemplo cl√°sico de un algoritmo de tiempo exponencial es el algoritmo recursivo para calcular los n√∫meros de Fibonacci. La secuencia de Fibonacci es una serie en la que cada n√∫mero es la suma de los dos n√∫meros anteriores, y empieza as√≠: 1, 1, 2, 3, 5, 8, 13...

La implementaci√≥n recursiva del c√°lculo de los n√∫meros de Fibonacci es la siguiente:

```javascript
const fibonacci = (num) => {
  if (num <= 1) return num;
  
  return fibonacci(num - 1) + fibonacci(num - 2);
}
```

Esto demuestra la naturaleza de la recursividad, donde una funci√≥n se llama a s√≠ misma dentro de su propia definici√≥n.

**Ejemplos de Uso Com√∫n**

Aunque los algoritmos con tiempo exponencial no se utilizan com√∫nmente en aplicaciones reales debido a su ineficiencia, tienen un valor did√°ctico muy alto. Sirven para entender conceptos fundamentales de la recursividad y c√≥mo la eficiencia de un algoritmo puede variar dr√°sticamente seg√∫n su implementaci√≥n.

Un ejemplo podr√≠a ser un sistema de recomendaci√≥n de productos que intente encontrar todas las combinaciones posibles de productos para maximizar el valor del carrito de la compra del cliente sin exceder un determinado presupuesto. Este es una variante del problema de la mochila (Knapsack Problem a fuerza bruta) y su resoluci√≥n directa puede implicar un tiempo de ejecuci√≥n exponencial.

**Ventajas y Desventajas**

La ventaja de los algoritmos de tiempo exponencial es su simplicidad conceptual, especialmente al mostrar c√≥mo funcionan los algoritmos recursivos. No obstante, su principal desventaja es su ineficiencia con conjuntos de datos m√°s grandes, donde pueden causar un desempe√±o considerablemente lento o incluso llegar a bloquear completamente el programa.

Aunque en su forma m√°s simple la funci√≥n de Fibonacci tiene un tiempo exponencial, se puede optimizar utilizando t√©cnicas como la memorizaci√≥n para reducir la complejidad a tiempo lineal.

**Diagramas**

El tiempo de ejecuci√≥n crece exponencialmente con cada adici√≥n a la entrada. Este es uno de los tiempos de ejecuci√≥n menos eficientes y puede verse en algunos problemas de b√∫squeda y optimizaci√≥n. Puedes graficar la funci√≥n f(x) = `2^x`.

<p align="center"><img width="50%" src="../images/bigonotation/big-o-3-7.png"/></p>

## Factorial Time- O(n!)

Los algoritmos con tiempo de ejecuci√≥n factorial, o `O(n!)`, tienen un tiempo de ejecuci√≥n que crece extremadamente r√°pido con cada nuevo elemento en la entrada. Estos algoritmos suelen ser los menos eficientes y su uso se limita a conjuntos de datos muy peque√±os. El ejemplo m√°s conocido de un algoritmo de tiempo factorial es el problema del viajante de comercio utilizando la estrategia de fuerza bruta.

El problema del viajante de comercio plantea la siguiente pregunta: "Dada una lista de ciudades y las distancias entre cada par de ciudades, ¬øcu√°l es la ruta m√°s corta posible que visita cada ciudad exactamente una vez y regresa a la ciudad de origen?" La estrategia de fuerza bruta para resolver este problema implica generar todas las posibles permutaciones de las ciudades e identificar la ruta con la menor distancia total, de ah√≠ su complejidad de `O(n!)`.

```javascript
// Este es un pseudoc√≥digo, no es una soluci√≥n completa para el problema del viajante de comercio
// Las funciones generateAllPermutations y calculateTotalDistance no est√°n implementadas en este ejemplo
const travellingSalesman = (cities) => {
  let shortestDistance = Infinity;
  let shortestPath;

  const permutations = generateAllPermutations(cities);
  
  permutations.forEach((path) => {
    const distance = calculateTotalDistance(path);
    
    if (distance < shortestDistance) {
      shortestDistance = distance;
      shortestPath = path;
    }
  });
  
  return shortestPath;
};
```

**Ejemplos de Uso Com√∫n**

Los algoritmos de tiempo factorial se utilizan a menudo en la generaci√≥n de permutaciones de un conjunto de datos. Por ejemplo, pueden ser √∫tiles en ciertos campos como la criptograf√≠a, donde la generaci√≥n de todas las posibles claves es necesaria para un ataque de fuerza bruta. En general, se evitan estos algoritmos debido a su rendimiento extremadamente pobre para tama√±os de entrada grandes. No obstante, en ciertos problemas como el del viajante de comercio, la fuerza bruta (aunque ineficiente) puede proporcionar la soluci√≥n √≥ptima.

**Ventajas y Desventajas**

El algoritmo de tiempo factorial puede ser √∫til cuando se necesita una soluci√≥n √≥ptima y el tama√±o de entrada es muy peque√±o. Sin embargo, para conjuntos de datos m√°s grandes, estos algoritmos son impracticables debido a su crecimiento factorial extremadamente r√°pido.

**Diagramas**

El tiempo de ejecuci√≥n crece extremadamente r√°pido y es el peor caso de complejidad. Puedes graficar la funci√≥n `f(x) = x!` (factorial de x).

<p align="center"><img width="50%" src="../images/bigonotation/big-o-3-8.png"/></p>

**Consejos**

- Minimiza el uso de algoritmos `O(n!)` siempre que sea posible: Aunque pueden ser necesarios para ciertos problemas, la complejidad factorial tiende a hacer que estos algoritmos sean inviables para conjuntos de datos de tama√±o considerable. Siempre busca alternativas m√°s eficientes antes de recurrir a un enfoque de fuerza bruta.

- Utiliza estrategias de optimizaci√≥n: Si te encuentras en una situaci√≥n en la que un algoritmo O(n!) es necesario, considera t√©cnicas de optimizaci√≥n como la poda, que puede eliminar ciertas ramas de c√°lculo si no es probable que produzcan una soluci√≥n √≥ptima.

- Analiza el tama√±o de tu entrada: A veces, un algoritmo `O(n!)` puede ser adecuado si sabes que tu conjunto de datos siempre ser√° peque√±o. En estos casos, la simplicidad de implementaci√≥n puede ser m√°s importante que la eficiencia.

**Conclusi√≥n**

Los algoritmos de tiempo factorial representan un l√≠mite en t√©rminos de ineficiencia en la inform√°tica. Aunque pueden ser √∫tiles para ciertos problemas, su aplicaci√≥n en la vida real es limitada debido a su exponencial crecimiento de tiempo de ejecuci√≥n. La comprensi√≥n de estos algoritmos sirve para reforzar la importancia de la eficiencia en la inform√°tica y subraya la necesidad de buscar enfoques m√°s optimizados para resolver problemas. Aprender a identificar y manejar estos casos puede ser una habilidad invaluable para cualquier programador.

## Graphing Big-O Notation

Aqu√≠ hay un gr√°fico que muestra los tiempos de ejecuci√≥n de `Big-O` mencionados anteriormente y su rendimiento a medida que aumenta el tama√±o de los datos
de entrada.

El **tiempo constante** es el tiempo de ejecuci√≥n con **mayor rendimiento** y el **tiempo factorial** es el de **peor rendimiento**.

<p align="center"><img width="50%" src="../images/bigonotation/big-o-3-9.png"/></p>

‚úçÔ∏è **Conclusi√≥n Final**

Entender la notaci√≥n Big-O es crucial para cualquier desarrollador de software. Proporciona un lenguaje universal para discutir el rendimiento de los algoritmos y nos ayuda a tomar decisiones m√°s informadas al seleccionar las estructuras de datos y algoritmos adecuados para nuestros programas. Este conocimiento no s√≥lo te ayudar√° a ser un programador m√°s eficiente, sino que tambi√©n ser√° invaluable durante las entrevistas t√©cnicas, donde a menudo se espera que justifiques tus elecciones de algoritmos y estructuras de datos con referencia a su complejidad de tiempo y espacio.

ü™î **Consejos Finales**

- **Pr√°ctica, pr√°ctica, pr√°ctica**: Como con cualquier concepto en inform√°tica, la mejor manera de entender realmente la notaci√≥n Big-O es aplic√°ndola en la pr√°ctica. Intenta identificar la complejidad de tiempo y espacio de los algoritmos en tu propio c√≥digo y en los problemas de entrevista t√©cnica.

- **No sobreoptimices**: Aunque siempre es importante tener en cuenta la eficiencia, recuerda que la legibilidad y la mantenibilidad del c√≥digo son igualmente importantes. No todas las situaciones requieren el algoritmo m√°s eficiente posible, especialmente si eso hace que el c√≥digo sea m√°s dif√≠cil de entender y mantener.

- **Aprende a equilibrar**: La elecci√≥n del algoritmo o estructura de datos correcta a menudo depende de un equilibrio entre el tiempo y el espacio. A veces, puedes conseguir un tiempo de ejecuci√≥n m√°s r√°pido utilizando m√°s memoria, o ahorrar memoria con un tiempo de ejecuci√≥n m√°s lento. Aprender a manejar este equilibrio es una habilidad clave para cualquier programador.

Espero que esta publicaci√≥n te haya proporcionado una visi√≥n clara de lo que es la notaci√≥n Big-O y c√≥mo se utiliza en la programaci√≥n para analizar la eficiencia de los algoritmos. Tu camino para convertirte en un desarrollador de software eficiente y consciente de la eficiencia est√° bien encaminado, aunque esto es solo una pizca de conocimiento el comienzo de un largo camino.

Tambi√©n puedes encontrar la versi√≥n en ingl√©s ingresando a [Blog Rooftop](https://tinyurl.com/big-o-part-3)

Gracias por leer esta serie de complejidad algor√≠tmica y espero verte en futuras publicaciones, aunque quiz√°s pueda ser sobre alg√∫n tema diferente. ¬°Hasta la pr√≥xima!

## Referencias
Si te interesa profundizar m√°s en el tema de la complejidad del tiempo y c√≥mo afecta la eficiencia de tus programas, puedes consultar los siguientes recursos:

- Libro: "Introduction to the Design and Analysis of Algorithms" por Anany Levitin.
- Libro: "Algorithms Unlocked" de Thomas H. Cormen.
- Libro: "Algorithms" de Robert Sedgewick and Kevin Wayne.
- Libro: "Algorithm Design Manual" de Steven S. Skiena.
- Libro: "Introduction to Algorithms - Fourth Edition" Thomas H. Cormen, Charles E. Leiserson, Ronald Rivest, Clifford Stein.

- Curso en l√≠nea: [Khan Academy: Algorithms](https://www.khanacademy.org/computing/computer-science/algorithms)
- Curso en l√≠nea: [GeekforGeeks: Binary Search](https://www.geeksforgeeks.org/binary-search/)
- Curso en l√≠nea: [Coursera: Algorithms, Part I](https://www.coursera.org/learn/algorithms-part1)
- Curso en l√≠nea: [Harvard's CS50: Introduction to Computer Science](https://www.edx.org/course/introduction-computer-science-harvardx-cs50x)
- Curso en l√≠nea: [Introduction to Algorithms by MIT](https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-fall-2011/)
- Curso en l√≠nea: [Algorithms, Part I by Princeton University](https://www.coursera.org/learn/algorithms-part1)
- Curso en l√≠nea: [Discrete Optimization by The University of Melbourne](https://www.coursera.org/learn/discrete-optimization)

- Video: [Logarithms in Computer Science](https://www.youtube.com/watch?v=kjDR1NBB9MU).
- Video: [Big O Notations (simple explanation)](https://www.youtube.com/watch?v=__vX2sjlpXU)
- Video: [Big O Notations](https://www.youtube.com/watch?v=v4cd1O4zkGw) de la serie "Computer Science Basics" por HackerRank en YouTube.
- Video: [Merge Sort vs. Quick Sort](https://www.youtube.com/watch?v=es2T6KY45cA)
- Video: [Bubble Sort Algorithm](https://www.youtube.com/watch?v=6Gv8vg0kcHc)
- Video: [The Travelling Salesman Problem](https://www.youtube.com/watch?v=zM5MW5NKZJg)
