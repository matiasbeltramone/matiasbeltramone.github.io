---
layout: post
title: "üß± Programando con Objetos: Lecci√≥n 2"
tags: [Paradigmas, POO, OOP, Orientaci√≥n a Objetos, Object Oriented]
---

Ahora que hemos establecido una base s√≥lida con clases y objetos, es hora de dar un paso m√°s. En esta segunda lecci√≥n de "Programando con Objetos", nos centraremos en un aspecto crucial de cualquier objeto en
la programaci√≥n orientada a objetos: su `estado`.

## Estados

Un objeto puede contender **datos**. Estos **datos** ser√°n guardados en **propiedades**. Una **propiedad** va a tener un `nombre` y un `tipo` (al menos en lenguajes tipados,
en los dem√°s lo hara por inferencia o _Duck Typing_), y puede ser rellenada, es decir, asignarle un valor en cualquier momento luego de la instanciaci√≥n de la clase.
Un lugar com√∫n para asignar valores a las **propiedades** es dentro del **constructor** para crear un objeto con un estado **consistente** seg√∫n el modelado que querramos representar.

- üìã **Definiendo propiedades y asignando valores**

```typescript
class Payment
{
  private someNumber: number;
  private someString: string;
  
  public construct()
  {
    this.someNumber = 10;
    this.someString = 'Hello, world!';
  }
}

const somePayment = new Payment();
```

Luego de la instanciaci√≥n de nuestro objeto `Payment`, tanto `someNumber` como `someString` tendr√°n como valores `10` y `'Hello, world!'` respectivamente.

Los datos contenidos en un **objeto** son conocidos tambi√©n como **estado** del mismo. Si esos datos van a ser fijos o lo que denominados `hardcoded`,
como vimos anteriormente, podr√≠amos hacerlo en la definici√≥n de la propiedad como **readonly** √≥ definiendo una constante para cada dato (seg√∫n el lenguaje de programaci√≥n se har√° de diferentes maneras, si es que fuera posible crear una constante, no siempre es posible...).

- üìã **Definiendo constantes o valores por defecto en propiedades**

```typescript
class Payment
{
  private readonly PI: number = 3.141516;
  private someString: string = 'Hello, world!';
}
```

La forma de declarar una **constante** depende en s√≠ de la sintaxis del lenguaje que utilices, de todas maneras para el ejemplo se entiende la manera utilizada (mediante readonly y valor por defecto en el caso de TypeScript).

Por otro lado, si el valor inicial de una propiedad debe ser variable, podemos dejar que el cliente de nuestra clase nos provea de un valor para nuestra propiedad
mediante un `argumento de constructor`. Agregando el par√°metro en el constructor, forzamos a nuestros clientes a proveer de un valor a nuestro argumento
en el momento de instanciar nuestra clase.

- üìã **Agregando un argumento a nuestro constructor**

```typescript
class Payment
{
  private someNumber: number;
  
  public construct(initialNumber: number)
  {
    this.someNumber = initialNumber;
  }
}

const invalidPayment = new Payment(); // No andar√° ya que el constructor pide un par√°metro de entrada (initialNumber)
const validPayment = new Payment(20);
```

Colocando las variables `someNumber` y `someString` como propiedades `private` (como vimos anteriormente) las hace solamente disponibles a las instancias de `Payment`.
Esto es llamado _scoping_. Los _scopes_ alternativos a las propiedades pueden ser `protected` y `public`.
Cuando hacemos una **propiedad** p√∫blica, la hacemos accesible para cualquier cliente (tanto para `Payment` misma, como para cualquier otra) que utilice la clase.

- üìã **Definiendo y utilizando propiedades p√∫blicas**

```typescript
class Payment
{
    public readonly SOME_NUMBER: number = 10;
    public someString: string;
    
    // ...
}

const validPayment = new Payment();

const number = validPayment.SOME_NUMBER;
validPayment.someString = 'Pagado';
```

Como `someNumber` fue definido como constante, no podemos modificarlo, pero si accederlo para traer su valor, en el caso de `someString`, no es constante,
pero si es p√∫blico por lo que nos permite realizarle modificaciones a su valor y ser accedido para obtener su valor tambi√©n.

---

### üí° Private should be your default scope

> En general, un _scope_ privado es preferible y deber√≠a ser tu opci√≥n por defecto (siempre que no termines agregando un `getX, setX` a la clase para poder modificarla igual y accederla facilmente sin una raz√≥n real). Limitando el acceso a los datos del objeto, nos ayuda a mantener los detalles de implementaci√≥n dentro del mismo objeto. Esto asegura que los **clientes no tienen** que lidiar o **manipular** directamente cualquier **dato** del objeto, ya que podr√≠an dejar al objeto en un **estado inconsistente**, lo que nos lleva a que siempre tendr√°n que hablar con el objeto a trav√©s de los m√©todos p√∫blicos explicitamente definidos, los cuales deber√≠an asegurarnos de dejar siempre a nuestro objeto en estados deseables o consistentes.

> _Property scoping_, es _class-based_, esto significa que si una propiedad esta como privada, **cualquier** instancia de la misma clase
tiene acceso a esta propiedad en cualquier instancia de la misma clase, inclu√≠da ella misma.

---

- üìã **Accediendo a una propiedad privada de otra instancia**

```typescript
class Payment
{
  private somePrice: number;
  // ...
  
  public getSomePrice(): number
  {
    return this.somePrice; // Payment, por supuesto, tiene acceso a su propia propiedad somePrice.
  }
  
  public getSomePriceFrom(other: Payment): number
  {
    return other.somePrice; // Payment tambi√©n tiene acceso a la propiedad privada somePrice de otra instancia de Payment ya que es del mismo tipo de clase.
  }
}

comst somePayment = new Payment();
const otherPayment = new Payment();

const priceOfSomePayment = otherPayment.getSomePriceFrom(somePayment); // Esto retornar√° el valor de la propiedad somePrice de la instancia somePayment.
```

Cuando el valor de una propiedad de un objeto puede cambiar durante su ciclo de vida, es considerado un _mutable object_.
Si ninguna de las propiedades del objeto pueden ser modificadas **luego** de la **instanciaci√≥n del mismo**, el objeto es considerado un _immutable object_.

- üìã **Objetos: Mutable vs Immutable**

```typescript
class Mutable
{
  private someNumber: number;
  
  public construct(initialNumber: number)
  {
    this.someNumber = initialNumber;
  }
  
  public increase(): void
  {
    this.someNumber = this.someNumber + 1;
  }
}
```

```typescript
class Immutable
{
  private someNumber: number;
  
  public construct(initialNumber: number)
  {
    this.someNumber = initialNumber;
  }
  
  public increase(): Immutable
  {
    return new Immutable(this.someNumber + 1);
  }
}
```

```typescript
const mutableObject = new Mutable(10);
mutableObject.increase();
```

Llamando al m√©todo increase() de un objeto mutable cambiar√° el estado del `mutableObject` en este ejemplo, cambiando el valor de la propiedad someNumber, es decir, al principio era 10 y luego de hacer el increase() al llamar a esta propiedad someNumber del objeto devolver√° 11.

```typescript
const inmutableObject = new Immutable(10);
const newInmutableObject = inmutableObject.increase();
```

Llamando al m√©todo `increase()` en un objeto immutable no cambiar√° el estado de la propiedad en el objeto `inmutableObject` en su lugar recibiremos una nueva instancia de un objeto inmutable con el nuevo valor de la propiedad someNumber incrementado, es decir, que el objeto `inmutableObject` tendr√° un valor de 10 en su propiedad `someNumber` y el objeto `newInmutableObject` tendr√° el valor de 11 en `someNumber`.

## üåü Conclusi√≥n: La Din√°mica de los Estados en la Programaci√≥n Orientada a Objetos

Hemos indagado sobre la complejidad y la belleza de los estados en los objetos de programaci√≥n. Desde explorar las propiedades b√°sicas hasta sumergirnos en las profundidades de los objetos mutables e inmutables,
hemos visto c√≥mo los estados dan vida y funcionalidad a nuestros objetos. Recordad que la forma en que gestionamos y modificamos estos estados puede tener un impacto significativo en la eficiencia, claridad y mantenibilidad de nuestro c√≥digo.

üí≠ Reflexiones Finales y Mirando hacia el Futuro
Como desarrolladores, es fundamental que comprendamos no solo c√≥mo codificar, sino tambi√©n por qu√© y cu√°ndo elegir ciertos enfoques sobre otros.
El manejo de estados es un pilar en este proceso de toma de decisiones, proporcionando la base para conceptos m√°s avanzados en la programaci√≥n orientada a objetos que exploraremos en futuras lecciones.

As√≠ que, mientras avanzamos en nuestro camino como programadores, recordemos siempre la importancia de construir una base s√≥lida y reflexiva en nuestros conocimientos.

<p align="center"><img width="50%" src="https://user-images.githubusercontent.com/22304957/211164605-ed461c29-b3c2-4eef-acf3-ad8cd9bdbbdc.png"/></p>
