---
layout: post
title: "‚è≥ Complejidad Algor√≠tmica"
tags: [A&D, Algorithmics, Big-O]
---

Dise√±ar y construir algoritmos es una parte integral del desarrollo de software. Aunque el objetivo principal de cada algoritmo es resolver un problema particular, es esencial considerar c√≥mo un algoritmo
realiza su trabajo y cu√°ntos recursos necesita para hacerlo, ya que en definitiva esto en alg√∫n momento se transformar√° en costos para nuestro cliente.
Estos recursos incluyen tanto el tiempo de c√°lculo, que se refiere a cu√°nto tiempo se necesita para ejecutar un algoritmo, como el espacio de memoria, que se refiere a cu√°nto almacenamiento requiere el algoritmo.
Esta necesidad de analizar la eficiencia de los algoritmos da lugar al estudio de la **complejidad algor√≠tmica**.

La complejidad algor√≠tmica es una m√©trica que nos permite cuantificar de manera precisa el rendimiento de un algoritmo en funci√≥n del tama√±o de su entrada.
Esto es crucial para comprender y predecir c√≥mo se comportar√° nuestro algoritmo con diferentes vol√∫menes de datos. Por ejemplo, un algoritmo que funcione bien con peque√±as cantidades de datos
puede ser ineficiente cuando se le da un conjunto de datos mucho m√°s grande, y a veces no es que necesite ser del orden de millones para que ya no sea tan performante como esperamos.

Adem√°s, la comprensi√≥n de la complejidad algor√≠tmica es de vital importancia durante el proceso de entrevistas t√©cnicas. Los entrevistadores suelen preguntar acerca de la complejidad
de los algoritmos para evaluar la habilidad del candidato para escribir c√≥digo eficiente y para valorar su capacidad de tomar decisiones informadas sobre los trade-offs entre tiempo y espacio.

En este art√≠culo, examinaremos m√°s de cerca la notaci√≥n Big-O, que se utiliza para describir la complejidad algor√≠tmica, y tambi√©n veremos las notaciones Big-Theta y Big-Omega.
Espero que este post te ayude a mejorar tu comprensi√≥n de estos conceptos fundamentales en ciencias de la computaci√≥n. ¬°Vamos a ello!

### ‚è≥ Complejidad Algor√≠tmica ¬øQu√© es?

Cada algoritmo o conjunto de instrucciones requiere un tiempo y espacio para ejecutarse, de manera que,
cuando dise√±amos algoritmos para solucionar nuestros problemas, es importante considerar su complejidad temporal y espacial.

Por lo general, solo escuchamos hablar de la notaci√≥n **Big-O** cuando hablamos de la complejidad y el rendimiento algor√≠tmico,
¬°Y... si, hay una raz√≥n para esto! Pero tambi√©n es importante comprender que existen **Big-Œ∏** (Big-Theta) y **Big-Œ©** (Big-Omega).

La notaci√≥n Big-O describe el rendimiento o complejidad m√°s lenta de un algoritmo.
Nos dice cu√°nto tiempo o espacio puede llegar a necesitar un algoritmo en el peor de los casos.

Por otro lado, Big-Œ© (Big-Omega) se utiliza para describir la complejidad espacial y temporal en el mejor de los casos
de un algoritmo. Este l√≠mite inferior asint√≥tico se refiere al tiempo o espacio m√≠nimo que requiere un algoritmo.
En cuanto a Big-Œ∏ (Big-Theta), describe la complejidad espacial y temporal promedio de un algoritmo,
lo que significa cu√°nto tiempo o espacio requiere un algoritmo en promedio para ejecutarse.

Entonces a medida que aumenta el tama√±o de nuestros datos ¬øC√≥mo afecta al rendimiento del algoritmo o a los requisitos de espacio del mismo?

Vamos a ilustrar esto con un ejemplo sencillo.

```javascript
const find = (array, value) => {
  for (const element of array) {
    if (element === value) {
      return true;
    }
  }
  
  return false;
}
```

En esta funci√≥n **buscamos un valor** espec√≠fico. El primer argumento es una colecci√≥n de valores para buscar y
el segundo argumento es el valor que estamos buscando.

Estamos usando un ciclo `for` para iterar a trav√©s de cada valor en la colecci√≥n y verificar si es igual al valor objetivo.
Si el valor est√° en la matriz, devuelve `true`; de lo contrario, devuelve `false` como mostramos en los siguientes fragmentos de c√≥digo.

```javascript
const array = [1, 2, 3, 4, 5];
const value = 3;

const result = find(array, value);

console.log(result); // esto imprimir√° "true" en la consola
```

```javascript
const array = [1, 2, 3];
const value = 4;

const result = find(array, value);

console.log(result); // esto imprimir√° "false" en la consola
```

‚åö ¬øCu√°nto tiempo tardar√° en ejecutarse este algoritmo? Bueno debemos pensar, ¬øcu√°l es nuestro peor escenario?

### Big-O 1Ô∏è‚É£
En el peor de los casos (Big-O), el valor que estamos buscando no se encuentra en la matriz,
y debemos recorrer todos los elementos de la matriz. Esto nos lleva a una complejidad temporal de `O(n)`.
A medida que aumenta la longitud de la matriz, el tiempo necesario para ejecutar este algoritmo aumenta de manera proporcional.

Si tenemos una matriz con 10 elementos, la cantidad m√°xima de veces que iteraremos a trav√©s de nuestra matriz
buscando este elemento es justamente 10.
Del mismo modo, si tenemos una matriz con 100 elementos, la cantidad m√°xima de veces que iteraremos
a trav√©s de nuestra matriz en busca de este elemento es 100.

Este tipo de algoritmo se conoce como **algoritmo de tiempo lineal** y se representa como **O(n)**
donde el rendimiento del algoritmo empeora proporcionalmente al tama√±o de la entrada, o dicho de otra manera el tiempo de ejecuci√≥n del algoritmo aumenta proporcionalmente al tama√±o de la entrada.

### Big-Œ© 2Ô∏è‚É£
En el mejor de los casos (Big-Œ©), el valor que buscamos se encuentra en el primer elemento de la matriz.
Esto nos dar√≠a una complejidad temporal de O(1).

### Big-Œ∏ 3Ô∏è‚É£ 
Para el caso promedio (Big-Œ∏), suponemos que debemos buscar en la mitad de la matriz antes de encontrar nuestro valor.
Esto nos dar√≠a una complejidad temporal de O(n/2), pero en la notaci√≥n Big-O, las constantes se ignoran,
por lo que tambi√©n ser√≠a O(n).

Aunque es m√°s com√∫n hablar sobre Big-O en la industria y en las entrevistas t√©cnicas, 
entender Big-Œ© y Big-Œ∏ te permitir√° tener una imagen m√°s completa de c√≥mo se desempe√±an los algoritmos en diferentes situaciones.

No deber√≠a necesitar conocer **Big-Œ∏** y **Big-Œ©** para una entrevista t√©cnica, pero es bueno estar familiarizado con ellos.

En futuros posts, exploraremos en detalle ejemplos m√°s complicados y c√≥mo identificar la complejidad algor√≠tmica. ¬°Espero que te unas a la serie!

Tambi√©n podes buscar la versi√≥n en ingl√©s dentro del [Blog Rooftop](https://tinyurl.com/big-o-part-1)

¬°Hasta la pr√≥xima! üëã
