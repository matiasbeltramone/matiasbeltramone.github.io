---
layout: post
title: "üß± Programando con Objetos: Lecci√≥n 1"
tags: [Paradigmas, POO, OOP, Orientaci√≥n a Objetos, Object Oriented]
---

## Clases y Objetos

Dado una clase, puedes crear cualquier n√∫mero de objetos. El comportamiento en tiempo de ejecuci√≥n (cuando el programa esta funcionando) de un objeto es definido por su definici√≥n de clase.
El siguiente c√≥digo muestra una simple clase, sin estado ni comportamiento, la cu√°l puede ser instanciada, es decir, permite la creaci√≥n de un objeto a partir de su clase.

- üìã **Clase m√≠nima y viable**

```typescript
class Payment
{
  // Sin c√≥digo
}

const computerPayment = new Payment();
const phonePayment = new Payment();

computerPayment == phonePayment // false
```

Si bien los objetos `computerPayment` y `phonePayment` pertenecen a la misma clase y no tienen atributos y comportamiento diferentes entre s√≠, no son lo mismo en la comparaci√≥n de ambos `objetos` ya que se comparan por valor de referencia a la variable que est√°n asociados. Si lo pensamos, en la realidad representan dos tipos de pagos diferentes, uno es el pago de una computadora y otro es el pago de nuestro celular como vemos en el ejemplo, y nuestra intuici√≥n nos dice que son dos cosas diferentes de alguna manera.

Una vez que tenemos una `instancia`, podemos llamar a cualquiera de sus m√©todos, en caso de que existan, no ser√≠a el caso del ejemplo anterior en el que esta completamente vacia la clase `Payment`.

- üìã **Llamando a un m√©todo en una instancia.**

```typescript
class Payment
{
  public markAsPaid(): void
  {
    // ...
  }
}

const computerPayment = new Payment();
computerPayment.markAsPaid();
```

Los **m√©todos de instancia**, como _markAsPaid()_, solo pueden ser llamados desde una **instancia** de clase.
Este tipo de m√©todos son llamados _object method_. Tambi√©n podemos definir m√©todos que pueden ser llamados **sin** una **instancia** determinada y estos son llamados _static methods._

- üìã **Definiendo un m√©todo est√°tico**

```typescript
class Payment
{
  public anObjectMethod(): void
  {
    // ...
  }
  
  public static aStaticMethod(): void
  {
    // ...
  }
}

const computerPayment = new Payment();
computerPayment.anObjectMethod(); // Necesita ser instanciado previamente como vemos en la l√≠nea anterior.

Payment.aStaticMethod(); // No necesita ser instanciado anteriormente, se puede utilizar desde la clase directamente.
```

Adem√°s de los **m√©todos de objeto** y **los m√©todos est√°ticos**, una clase tambi√©n puede contener un m√©todo especial llamado: _constructor_.
Se llamar√° a este m√©todo antes de que se devuelva una referencia al objeto. Si necesita hacer cualquier cosa para preparar el objeto
en un estado determinado antes de que se vaya a usar, podr√≠amos hacerlo mediante el _constructor_ de la clase, donde dependiendo del lenguaje su declaraci√≥n
es de una manera u otra, para ejemplificar le colocaremos un nombre `constructor()` como hace `JavaScript / Typescript` en nuestro caso, pero en otros casos este m√©todo se declara con el mismo nombre que la clase ejemplo `public Payment(args...) { // Prepare object... }`.

- üìã **Definiendo un m√©todo constructor**

```typescript
class Payment
{
  public constructor()
  {
    // Preparar el objeto adeacuadamente...
  }
}

const computerPayment = new Payment();
```

En este caso el m√©todo contructor de la clase no realiza ninguna acci√≥n por lo tanto simplemente har√° la creaci√≥n del objeto `Payment` en este caso representado por la variable `computerPayment`.

Podr√≠amos hacer algunas validaciones previo a la creaci√≥n de la instancia u objeto y adem√°s podemos evitar que se cree una instancia completa de un objeto lanzando una **excepci√≥n** dentro del constructor, como se muestra en el siguiente c√≥digo.

- üìã **Lanzando una excepci√≥n dentro del constructor**

```typescript
class Payment
{
  public construct()
  {
    throw new RuntimeException(); // No ser√° posible instanciar el objeto Payment ya que su constructor siempre lanza una excepci√≥n pase lo que pase.
  }
}

try {
  const computerPayment = new Payment();
} catch (RuntimeException exception) {
  // `computerPayment` ser√° undefined aqu√≠ ya que nunca se llego a instanciar Payment.
}
```

Si queremos saber m√°s sobre excepciones m√°s adelante abordaremos sobre el tema en particular pero en definitiva cortan nuestro flujo de ejecuci√≥n ya que le decimos al programa que algo inesperado ha pasado y por lo tanto tenemos que manejar este error ocurrido de alguna manera, as√≠ sea que el manejo sea no hacer nada, lo m√°s com√∫n es dejar un **Log** (otro tema importante para abordar en otro momento...) en nuestra aplicaci√≥n para poder visualizar que error/es ocurrierron.

- üìã **Definiendo contructores sem√°nticos (_named constructors_)**

```typescript
class Payment
{
  private construct(...)
  {
     // Asignaci√≥n de propiedades...
  }
  
  public static make(): Payment
  {
    // Validaciones, y otras responsabilidades...
    
    return new Payment(...);
  }
}

const computerPayment = Payment.make();
const phonePayment = Payment.make();
```

El m√©todo `make()` debe definirse como est√°tico porque debe invocarse en la clase directamente, y no en una instancia particular de esa clase,
es un medio para crear la propia clase de una manera directa y m√°s sem√°ntica, permitiendo como veremos m√°s adelante realizar **validaciones** (si... m√°s temas de estudio) respectivas a los argumentos de entrada o estados de la clase para respetar la **integridad** del **objeto**, previo a realizar la construcci√≥n del mismo, es decir, antes de hacer el `new Payment(...)`.

<p align="center"><img width="50%" src="https://user-images.githubusercontent.com/22304957/211164605-ed461c29-b3c2-4eef-acf3-ad8cd9bdbbdc.png"/></p>
